import json
import re
from argparse import ArgumentParser
from copy import deepcopy
from dataclasses import dataclass
from contextlib import suppress
from functools import cached_property
from logging import getLogger
from pathlib import Path
from typing import Iterable, List, Optional, Tuple


log = getLogger(__name__)


@dataclass(frozen=True)
class Parameter:
    """
    A class representing 1 particular configuration unit from swagger file.

    Examples:
        (path='/v1/users/{id}', method='get', in_='header', name='App-Token')
        (path='/v1/users/{id}', method='get', in_='header', name='Auth-Token')
        (path='/v1/users/{id}', method='get', in_='query', name='id')
    """

    path: str
    method: Optional[str]
    in_: Optional[str]
    name: Optional[str]

    @cached_property
    def re_path(self) -> re.Pattern:
        # /users/{id}/projects -> /users/(?P<id>\d+)/projects
        return re.compile('^' + re.sub(r'\{(.+?)\}', r'(?P<\1>\\d+)', self.path) + '$')

    def __eq__(self, other) -> bool:
        """
        Parameters are equal if their fields are equal. None value matches every other value (i.e. None == wildcard).
        These are equal:
            (path='/v1/users/{id}', method='get', in_='header', name='App-Token')
            (path='/v1/users/{id}', method='get', in_=None, name=None)
        """
        for field_ in self.__annotations__:
            # we do case-insensitive comparison bc case may change
            # (field name will be capitalized if transformed into header, and vice versa)
            val1 = getattr(self, field_)
            val2 = getattr(other, field_)

            if val1 is None or val2 is None:
                continue

            val1 = val1.lower()
            val2 = val2.lower()

            if val1 == val2:
                continue

            if field_ == 'path':

                with suppress(re.error):
                    if '{' in val1 and self.re_path.match(val2):
                        continue

                with suppress(re.error):
                    if '{' in val2 and other.re_path.match(val1):
                        continue

            return False

        return True


@dataclass
class ApiMixer:
    """
    Given any dictionary in Swagger format, perform random substitutions of specific fields.

    "Randomness" is consistent across runs and depends only on seed.

    Permutation is achieved by following steps:
    1) Swagger file is parsed and converted into list of Parameters.
       Parameter is just a tuple of path, method, value location, and value itself:
       (path='/v1/users/{id}', method='get', in_='header', name='App-Token')
    2) A permuted list of parameters is generated by applying "permutations" - functions
       which take single Parameter and transform it to another Parameter.
    3) In the end we have list of original parameters and s probably convertedimilar list with those parameters
       after permutations, which is 1-to-1 mapping (mapping is done by indexes, i.e.
       parameters[i] ---> permuted_parameters[i]).
    4) Now, when a request comes to the application, it is parsed to a set of permuted
       parameters, those are converted back to original parameters using the mapping from step 3,
       and original parameters are used to construct "real" request to Hubstaff API.
    5) Response from Hubstaff API is returned back to user.
    """

    swagger: dict
    seed: int

    permutations: Iterable[callable] = tuple()
    request_processors: Iterable[callable] = tuple()
    result_processors: Iterable[callable] = tuple()

    def __post_init__(self):

        # apply permutations on swagger copy
        self.permuted_swagger = deepcopy(self.swagger)
        for permutation in self.permutations:
            permutation(self.permuted_swagger, self.seed)

        # generate all parameters for original and permuted swagger definitions
        self.original_parameters = self.as_parameters(self.swagger)
        self.permuted_parameters = self.as_parameters(self.permuted_swagger)

    @classmethod
    def as_parameters(cls, swagger: dict) -> List[Parameter]:
        """
        Covert a hierarchical swagger definition to a list of parameters.

        Example output: [
            # parameters from /v1/users/{id} endpoint:
            Parameter(path='/v1/users/{id}', method='get', in_='header', name='App-Token')
            Parameter(path='/v1/users/{id}', method='get', in_='header', name='Auth-Token')
            Parameter(path='/v1/users/{id}', method='get', in_='query', name='id'),
            # parameters for other endpoints:
            ...
        ]
        """

        parameters = []

        for path, methods in swagger['paths'].items():
            for method, description in methods.items():

                if 'parameters' not in description:
                    # if no parameters for this endpoint, we just create a wildcard dummy parameter,
                    # so that we remember path and method
                    parameters.append(Parameter(path, method, None, None))
                else:
                    for parameter in description['parameters']:
                        parameters.append(Parameter(path, method, parameter['in'], parameter['name']))

        return parameters

    def reverse(self, permuted_parameter: Parameter) -> Tuple[Parameter, Parameter]:
        """
        Convert permuted parameter to permuted definition + original parameter.
        Raises ValueError if permuted parameter is not expected.
        """
        idx = self.permuted_parameters.index(permuted_parameter)
        permuted_definition = self.permuted_parameters[idx]
        original_definition = self.original_parameters[idx]
        return permuted_definition, original_definition


if __name__ == '__main__':
    parser = ArgumentParser()
    parser.add_argument('--swagger_file', type=Path, default='data/hubstaff.v1.swagger.json')
    parser.add_argument('--seed', type=int, default=1)
    args = parser.parse_args()

    swagger_data = json.loads(args.swagger_file.read_text())
    mixer = ApiMixer(swagger_data, args.seed)

    print(json.dumps(mixer.permuted_swagger['paths'], indent=4, default=str))
